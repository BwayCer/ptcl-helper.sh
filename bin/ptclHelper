#!/bin/bash
# 怕蒂瑪其小幫手腳本


##shStyle ###


_originPlace="lib"

_shScript() {
    case "$1" in
    blkid ) _shCmdLevel=1 ;;
    esac
}


##shStyle 介面函式


fnHelp_main() { echo "# 備份小幫手，通過 sgdisk 及 partclone 備份裝置。
[[USAGE]] [多個參數]
[[SUBCMD]]
  blkid    $fnHelp_blkid_briefly
[[OPT]]
  -h, --help                 幫助。
"; }
fnOpt_main() {
    case "$1" in
        -h | --help ) fnShowHelp ;;
        * )
            if [ -z "$2" ]; then
                opt_carryOpt+="$1 "
                return 1
            else
                opt_carryOpt+="$1=\"$2\" "
                return 2
            fi
            ;;
    esac
}
fnMain() {
    [ $# -eq 0 ] && fnShowHelp

    opt_carryOpt=""
    fnParseOption

    printf "執行主命令\n  攜帶選項： %s\n  攜帶參數： %s\n" "$opt_carryOpt" "(${#_args[@]}) ${_args[*]}"
}

fnHelp_blkid_briefly="顯示 \`blkid\` 資訊。"
fnHelp_blkid() { echo "# $fnHelp_blkid_briefly
[[USAGE]] $help_allowDevice
[[OPT]]
  -s, --show <tag>[,...]   顯示指定標籤。 預設為 \"PTTYPE,UUID,PARTUUID\"。
  -h, --help               幫助。
"; }
fnOpt_blkid() {
    case "$1" in
        -s | --show )
            [ -z "$2" ] && return 4

            opt_show="$2"
            return 2
            ;;
        -h | --help ) fnShowHelp ;;
        * ) return 3 ;;
    esac
}
fnMain_blkid() {
    [ $# -eq 0 ] && fnShowHelp

    opt_show="PTTYPE,UUID,PARTUUID"
    fnParseOption

    fnParseDeviceList "${_args[@]}"
    fnBlkidTable "$opt_show" \
        "${rtnParseDeviceList_pt[@]}" \
        "${rtnParseDeviceList_store[@]}"
}


##shStyle 共享變數


help_allowDevice='<裝置 ex: "/dev/sdx","/dev/sdxN">[...]'


##shStyle 函式庫


rtnCutArray=()
fnCutArray() {
    local separator strTxt
    separator="$1"
    strTxt="$2"

    local idx val
    local arrAns=()

    idx=2
    while [ 1 ]
    do
        val=`echo "$separator$strTxt" | cut -d "$separator" -f $idx`
        [ "$val" == "" ] && break
        arrAns[ ${#arrAns[@]} ]=$val
        (( idx++ ))
    done

    rtnCutArray=("${arrAns[@]}")
}

fnRandomStr() {
    local loop rem
    local random=$RANDOM
    local strAns=""
    for loop in {1..2}
    do
        rem=$[ $random & 15 ]
        random=$[ $random >> 4 ]
        strAns+=${fnRandomStr_count16:$rem:1}
    done
    echo $strAns
}
fnRandomStr_count16="0123456789ABCDEF"

fnCheckMountState() {
    [ -z "$*" ] && return
    [ $fnCheckMountState_hasCheck -eq 1 ] && return

    local tmp val
    local bisHasNotCheck=0
    local bisHasUmount=0

    ## lsblk img
    # 錯誤 lsblk 不能處理非裝置
    # 但若執行 /dev/loop 又會因為未卸載而退出
    for val in "$@"
    do
        tmp=`lsblk -o MOUNTPOINT "$val" 2> /dev/null`
        if [ $? -ne 0 ]; then
            bisHasNotCheck=1
            printf "$_fYelB%s$_fN\n" \
                "無法確認 \"$val\" 是否已卸載！"
        elif [ -n "`echo "$tmp" | sed "1d" | grep .`" ]; then
            bisHasUmount=1
            Loxog err "請卸載 \"$val\" 裝置。"
        fi
    done

    [ $bisHasUmount -eq 1 ] && exit 1

    if [ $bisHasNotCheck -eq 1 ]; then
        printf "$_fYelB%s\n%s$_fN %s" \
            "！！！ 未卸載的裝置可能會有誤刪資料的風險 ！！！" \
            "請手動檢查無法確認之裝置。" \
            "（<Ctrl+c> 退出； <Enter> 繼續；）"
        read
        echo
    fi

    fnCheckMountState_hasCheck=1
}
fnCheckMountState_hasCheck=0
fnCheckMountState_hasNotCheck=0

rtnParseDeviceList_pt=()
rtnParseDeviceList_store=()
fnParseDeviceList() {
    if [ -z "$*" ]; then
        Loxog err "未指定裝置。"
        exit 1
    fi

    local val ptType
    local hasNoAllowDevice=0
    local devicePtList=()
    local deviceList=()

    for val in "$@"
    do
        ptType=`blkid -o value -s PTTYPE "$val"`
        if [ $? -ne 0 ]; then
            hasNoAllowDevice=1
            Loxog err "找不到 \"$val\" 裝置。"
            continue
        elif [ -n "$ptType" ] && [ "$ptType" != "gpt" ]; then
            hasNoAllowDevice=1
            Loxog err '尚未對非 "GPT" 分區表的裝置提供服務。'
            continue
        fi

        [ "$ptType" == "gpt" ] \
            && devicePtList[ ${#devicePtList[@]} ]=$val \
            || deviceList[ ${#deviceList[@]} ]=$val
    done

    [ $hasNoAllowDevice -ne 0 ] && exit 1
    fnCheckMountState "${devicePtList[@]}" "${deviceList[@]}"

    rtnParseDeviceList_pt=("${devicePtList[@]}")
    rtnParseDeviceList_store=("${deviceList[@]}")
}

# lsblk 資訊時而空白
fnBlkidTable() {
    local showList="$1"; shift

    fnCutArray "," "$showList"
    showList=("${rtnCutArray[@]}")

    local tmp idx val deviceName
    local blkidInfo=""
    local arrInfo=()
    local txtInfo=""
    local formatArgus=""
    local strAns=""

    for deviceName in "$@"
    do
        txtInfo+=$_br"0 $deviceName"
        arrInfo[ ${#arrInfo[@]} ]=$deviceName

        idx=1
        for val in "${showList[@]}"
        do
            blkidInfo=`blkid -s "$val" -o value "$deviceName"`
            arrInfo[ ${#arrInfo[@]} ]=$blkidInfo
            txtInfo+=$_br"$idx $blkidInfo"
            (( idx++ ))
        done
    done

    idx=1
    for idx in `seq 0 ${#showList[@]}`
    do
        tmp=${showList[ $(( $idx - 1 )) ]}$_br
        tmp+=`echo "$txtInfo" | grep "^$idx " | cut -d " " -f 2-`
        formatArgus+="   %-"`echo "$tmp" | wc -L`"s"
    done
    formatArgus=${formatArgus:3}$_br

    printf "$formatArgus" "DEVNAME" "${showList[@]}"
    printf "$formatArgus" "${arrInfo[@]}"
}


##shStyle 腳本環境


[ -L "$0" ] && exec "`realpath "$0"`" "$@"

__filename=`realpath "$0"`
_dirsh=`dirname "$__filename"`
[ "$_originPlace" == "bin" ] && _binsh=$_dirsh || _binsh=`realpath "$_dirsh/../../bin"`
[ "$_originPlace" == "bin" ] && _libsh=`realpath "$_dirsh/../lib"` || _libsh=`realpath "$_dirsh/.."`
_fileName=`basename "$0"`

_IFS=$IFS
_br="
"

tmp=`tput colors`
if [ -t 1 ] && [ -n "$tmp" ] && [ $tmp -ge 8 ]; then
    _fN=`tput sgr0`
    _f_bold=`tput bold`
    _fRed=`tput setaf 1`
    _fYel=`tput setaf 3`
    _fRedB=$_fRed$_f_bold
    _fYelB=$_fYel$_f_bold
fi

Loxog() {
    local _stdin=`[ ! -t 0 ] && { \
        IFS='';
        while read pipeData; do echo "$pipeData"; done <&0;
        IFS=$_IFS;
    }`
    local method="$1"; shift

    local color formatArgus

    case $method in
        war ) color=$_fYelB ;;
        err ) color=$_fRedB ;;
    esac

    formatArgus="$color%s$_fN\n"

    local idx val len

    [ -n "$*" ] && printf "$formatArgus" "$@" 1>&2

    [ -z "$_stdin" ] && return
    len=`echo "$_stdin" | wc -l`
    for idx in `seq 1 $len`
    do
        val=`echo "$_stdin" | sed -n "${idx}p"`
        printf "$formatArgus" "$val" 1>&2
    done
}


##shStyle ###


_stdin=`[ ! -t 0 ] && while read pipeData; do echo $pipeData; done <&0`

_args=("$@")
_origArgs=("$@")

argsShift() {
    local amount=$1

    if [ -z "$amount" ] || [ $amount -lt 1 ]; then amount=1; fi
    _args=("${_args[@]:$amount}")
}

_fnForceColor() {
    _fN="\e[00m"
    _f_bold="\e[01m"
    _fRed="\e[31m"
    _fYel="\e[33m"
    _fRedB=$_fRed$_f_bold
    _fYelB=$_fYel$_f_bold
}

fnParseOption() {
    local fnHandleOpt="fnOpt_$_shCmd"

    local tmp args opt val cutLen errMsg
    args=("${_args[@]}")
    errMsg=""

    while [ 1 ]
    do
        opt=${args[0]}
        val=${args[1]}
        cutLen=2

        if [ "$opt" == "--" ] || [ -z "`echo "_$opt" | grep "^_-"`" ]; then break; fi

        if [ -n "`echo "_$opt" | grep "^_-[^-]"`" ] && [ ${#opt} -ne 2 ]; then
            tmp="-"${opt:2}
            opt=${opt:0:2}
            val=""
            cutLen=1
            args=("$opt" "$tmp" "${args[@]:1}")
        elif [ -n "`echo "_$val" | grep "^_-"`" ]; then
            val=""
            cutLen=1
        fi

        if [ "$opt" == "--color" ]; then
            _fnForceColor
            tmp=1
        else
            $fnHandleOpt "$opt" "$val"
            tmp=$?
        fi
        case $tmp in
            0 )
                echo '請檢查 "'$fnHandleOpt'" 的錯誤回傳值。' 1>&2
                exit
                ;;
            # 使用 1 個參數
            1 )
                [ $cutLen -eq 2 ] && (( cutLen-- ))
                ;;
            # 使用 2 個參數
            2 ) ;;
            3 )
                errMsg+=$_br'找不到 "'$opt'" 選項。'
                ;;
            4 )
                [ "$val" == "" ] && val="null" || val='"'$val'"'
                errMsg+=$_br$val' 不符合 "'$opt'" 選項的預期值。'
                ;;
        esac

        args=("${args[@]:$cutLen}")
    done

    if [ "${args[0]}" == "--" ]; then
        args=("${args[@]:1}")
    else
        for val in "${args[@]}"
        do
            [ -z "`echo "_$val" | grep "^_-"`" ] && continue

            errMsg+=$_br'不符合 "[命令] [選項] [參數]" 的命令用法。'
            break
        done
    fi

    if [ -z "$errMsg" ]; then
        _args=("${args[@]}")
        return
    fi

    echo "$errMsg" | sed "1d" \
        | sed "s/^\(.\)/[$_fileName]: \1/" \
        | Loxog err
    exit 1
}

fnShowHelp() {
    local txtHelp=`fnHelp_$_shCmd`

    local bisUsage bisSubCmd bisOpt
    local usage
    bisUsage=` echo "$txtHelp" | grep "\[\[USAGE\]\]"`
    bisSubCmd=`echo "$txtHelp" | grep "\[\[SUBCMD\]\]"`
    bisOpt=`   echo "$txtHelp" | grep "\[\[OPT\]\]"`

    if [ -n "$bisUsage" ]; then
        usage="用法："
        [ -n "$bisSubCmd" ] && usage+=" [命令]"
        [ -n "$bisOpt" ] && usage+=" [選項]"

        txtHelp=`echo "$txtHelp" | sed "s/\[\[USAGE\]\]/\n$usage/"`
    fi

    [ -n "$bisSubCmd" ] && \
        txtHelp=`echo "$txtHelp" | sed "s/\[\[SUBCMD\]\]/\\n\\n命令：\\n/"`

    [ -n "$bisOpt" ] && \
        txtHelp=`echo "$txtHelp" | sed "s/\[\[OPT\]\]/\\n\\n選項：\\n/"`

    echo "$txtHelp$_br"
    exit
}


_shCmd=""
_shCmdLevel=0
_shScript "$@"
[ $_shCmdLevel -eq 0 ] && _shCmd="main" && fnMain "$@" && exit
for tmp in `seq 0 $(( $_shCmdLevel -1 ))`
do _shCmd+="_${_args[ $tmp ]}"; done
argsShift $_shCmdLevel
_shCmd=${_shCmd:1}
fnMain_$_shCmd "${_args[@]}"

