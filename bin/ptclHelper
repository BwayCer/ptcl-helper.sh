#!/bin/bash
# 帕蒂瑪其小幫手腳本


##shStyle ###


_originPlace="lib"

# 避免語言支持不完全，如： df。
export LC_ALL=C

_shScript() {
    if [ "`id -u`" != "0" ]; then
        Loxog err "請使用 root 身分執行。"
        exit 1
    fi


    case "$1" in
    blkid  ) _shCmdLevel=1 ;;
    info   ) _shCmdLevel=1 ;;
    backup ) _shCmdLevel=1 ;;
    esac
}


##shStyle 介面函式


fnHelp_main() { echo "# 備份小幫手，通過 sgdisk 及 partclone 備份裝置。
$help_partcloneOptExplain
[[USAGE]] <備份儲存位置> $help_allowDevice
[[SUBCMD]]
  blkid     $fnHelp_blkid_briefly
  info      $fnHelp_info_briefly
  backup    $fnHelp_backup_briefly
[[OPT]]
$help_partcloneOpt
  -h, --help                 幫助。
"; }
fnOpt_main() {
    case "$1" in
        -h | --help ) fnShowHelp ;;
        * ) fnOpt_partcloneOpt "$@" ;;
    esac
}
fnMain() {
    [ $# -eq 0 ] && fnShowHelp

    opt_partcloneOpt=""
    fnParseOption

    local tmp
    local dirPath="${_args[0]}"

    if [ -z "$dirPath" ]; then
        Loxog err "未指定備份儲存位置。"
        exit 1
    elif [ -e "$dirPath" ] && [ ! -d "$dirPath" ]; then
        Loxog err "指定的備份位置存在文件。"
        exit 1
    elif [ -d "$dirPath" ] && [ -n "`ls -A "$dirPath"`" ]; then
        Loxog err "指定的備份位置不為空目錄。"
        exit 1
    fi

    fnParseDeviceList "${_args[@]:1}"
    local devicePtList=("${rtnParseDeviceList_pt[@]}")
    local deviceList=("${rtnParseDeviceList_store[@]}")

    local mdInfo
    local shHead="#!/bin/bash$_br#$_br"
    local pathTxt=""
    local shCodeTxt=""
    local restoreGptSh=""
    local cloneGptSh=""
    local restoreSh=""
    local cloneSh=""

    fnTxtPathForm() {
        [ -n "$pathTxt" ] && pathTxt+=$_br
        pathTxt+="─┬ $1"
        pathTxt+=$_br" ├── 還原 -> $dirPath/$2.sh"
        pathTxt+=$_br" └── 備份 -> $dirPath/$3.sh"
    }

    if [ ${#devicePtList[@]} -ne 0 ]; then
        fnTxtPathForm "分區表裝置" "restoreGpt" "cloneGpt"
        fnBackupCode GPT "" "${devicePtList[@]}"
        restoreGptSh=$shHead"$rtnBackupCode_restore"
        cloneGptSh=$shHead"$rtnBackupCode_clone"
    fi
    if [ ${#deviceList[@]} -ne 0 ]; then
        fnTxtPathForm "儲存裝置" "restore" "clone"
        fnBackupCode store "$opt_partcloneOpt" "${deviceList[@]}"
        restoreSh=$shHead"$rtnBackupCode_restore"
        cloneSh=$shHead"$rtnBackupCode_clone"
    fi

    tmp="留存裝置資訊"
    printf "$tmp ( 讀取中 ... )"
    fnGetInfo_devicePtList=("${devicePtList[@]}")
    fnGetInfo_deviceList=("${deviceList[@]}")
    fnGetInfo
    mdInfo=$rtnGetInfo
    pathTxt="── 裝置資訊 -> $dirPath/hostInfo.txt"$_br$pathTxt
    printf "\r\e[K%s\n\n" "$tmp ( 成功 )"

    if [ ! -d "$dirPath" ]; then
        mkdir -p "$dirPath"
        tmp=$?; [ $tmp -ne 0 ] && exit $tmp
    fi

    echo "$pathTxt"
    echo "$mdInfo" > "$dirPath/hostInfo.txt"
    if [ -n "$restoreGptSh" ]; then
        echo "$restoreGptSh" > "$dirPath/restoreGpt.sh"
        echo "$cloneGptSh" > "$dirPath/cloneGpt.sh"
        chmod 755 "$dirPath/restoreGpt.sh" "$dirPath/cloneGpt.sh"
    fi
    if [ -n "$restoreSh" ]; then
        echo "$restoreSh" > "$dirPath/restore.sh"
        echo "$cloneSh" > "$dirPath/clone.sh"
        chmod 755 "$dirPath/restore.sh" "$dirPath/clone.sh"
    fi
}

fnHelp_blkid_briefly="顯示 \`blkid\` 資訊。"
fnHelp_blkid() { echo "# $fnHelp_blkid_briefly
[[USAGE]] $help_allowDevice
[[OPT]]
  -s, --show <tag>[,...]   顯示指定標籤。 預設為 \"PTTYPE,UUID,PARTUUID\"。
  -h, --help               幫助。
"; }
fnOpt_blkid() {
    case "$1" in
        -s | --show )
            [ -z "$2" ] && return 4

            opt_show="$2"
            return 2
            ;;
        -h | --help ) fnShowHelp ;;
        * ) return 3 ;;
    esac
}
fnMain_blkid() {
    [ $# -eq 0 ] && fnShowHelp

    opt_show="PTTYPE,UUID,PARTUUID"
    fnParseOption

    fnParseDeviceList "${_args[@]}"
    fnBlkidTable "$opt_show" \
        "${rtnParseDeviceList_pt[@]}" \
        "${rtnParseDeviceList_store[@]}"
}

fnHelp_info_briefly="留存當前裝置資訊供還原後對照。"
fnHelp_info() { echo "# $fnHelp_info_briefly
[[USAGE]] $help_allowDevice
[[OPT]]
  -h, --help   幫助。
"; }
fnOpt_info() {
    case "$1" in
        -h | --help ) fnShowHelp ;;
        * ) return 3 ;;
    esac
}
fnMain_info() {
    [ $# -eq 0 ] && fnShowHelp

    fnParseOption

    fnParseDeviceList "${_args[@]}"
    fnGetInfo_devicePtList=("${rtnParseDeviceList_pt[@]}")
    fnGetInfo_deviceList=("${rtnParseDeviceList_store[@]}")
    fnGetInfo
    echo "$rtnGetInfo"
}

fnHelp_backup_briefly="顯示備份或還原的相關文件。"
fnHelp_backup() { echo "# $fnHelp_backup_briefly
$help_partcloneOptExplain
[[USAGE]] <備份儲存位置> $help_allowDevice
[[OPT]]
  -i, --info                 $fnHelp_info_briefly
$help_partcloneOpt
  -h, --help                 幫助。
"; }
fnOpt_backup() {
    case "$1" in
        -i | --info )
            opt_Info=1
            return 1
            ;;
        -h | --help ) fnShowHelp ;;
        * ) fnOpt_partcloneOpt "$@" ;;
    esac
}
fnMain_backup() {
    [ $# -eq 0 ] && fnShowHelp

    opt_Info=0
    opt_partcloneOpt=""
    fnParseOption

    local tmp
    local dirPath="${_args[0]}"

    if [ -z "$dirPath" ]; then
        Loxog err "未指定備份儲存位置。"
        exit 1
    fi

    fnParseDeviceList "${_args[@]:1}"
    local devicePtList=("${rtnParseDeviceList_pt[@]}")
    local deviceList=("${rtnParseDeviceList_store[@]}")

    local shHead="#!/bin/bash$_br#$_br"
    local pathTxt=""
    local shCodeTxt=""

    fnTxtForm() {
        local method="$1"
        case "$method" in
            path )
                [ -n "$pathTxt" ] && pathTxt+=$_br
                pathTxt+="─┬ $4"
                pathTxt+=$_br" ├── 還原 -> $dirPath/$2.sh"
                pathTxt+=$_br" └── 備份 -> $dirPath/$3.sh"
                ;;
            code )
                [ -n "$shCodeTxt" ] && shCodeTxt+=$_br$_br
                shCodeTxt+="## $dirPath/$2.sh"$_br$shHead$4
                shCodeTxt+=$_br$_br
                shCodeTxt+="## $dirPath/$3.sh"$_br$shHead$5
                ;;
        esac
    }

    if [ ${#devicePtList[@]} -ne 0 ]; then
        fnTxtForm path "restoreGpt" "cloneGpt" "分區表裝置"

        fnBackupCode GPT "" "${devicePtList[@]}"
        fnTxtForm code "restoreGpt" "cloneGpt" \
            "$rtnBackupCode_restore" "$rtnBackupCode_clone"
    fi
    if [ ${#deviceList[@]} -ne 0 ]; then
        fnTxtForm path "restore" "clone" "儲存裝置"

        fnBackupCode store "$opt_partcloneOpt" "${deviceList[@]}"
        fnTxtForm code "restore" "clone" \
            "$rtnBackupCode_restore" "$rtnBackupCode_clone"
    fi

    if [ $opt_Info -eq 1 ]; then
        printf "留存裝置資訊 ( 讀取中 ... )"
        fnGetInfo_devicePtList=("${devicePtList[@]}")
        fnGetInfo_deviceList=("${deviceList[@]}")
        fnGetInfo
        pathTxt="── 裝置資訊 -> $dirPath/hostInfo.txt"$_br$pathTxt
        printf "\r\e[K%s\n" "$rtnGetInfo"
        for tmp in {1..9}; do printf "=-------"; done; echo -e "=\n\n"
    fi

    echo "$pathTxt$_br$_br"'```'"$_br$shCodeTxt$_br"'```'
}


##shStyle 共享變數


help_allowDevice='<裝置 ex: "/dev/sdx","/dev/sdxN">[...]'

help_partcloneOptExplain="# \`partclone\` 相關選項可以查看 \`man partclone\` 說明。"
help_partcloneOpt="
  -D, --domain               Create ddrescue domain log from source device.
                             \`partclone\` 相關選項。
      --offset_domain <X>    Add offset X (bytes) to domain log values.
                             \`partclone\` 相關選項。
      --restore_raw_file     create special raw file for loop device.
                             \`partclone\` 相關選項。
  -l, --logfile <logfile>    輸出 partclone 日誌訊息到指定路徑。
                             預設為 /var/log/partclone.log。
                             \`partclone\` 相關選項。
  -R, --rescue               即使有錯誤仍繼續執行。 \`partclone\` 相關選項。
  -C, --no_check             不要檢查設備的大小和可用空間。
                             \`partclone\` 相關選項。
  -N, --ncurse               Using Ncurses User Interface.
                             \`partclone\` 相關選項。
  -X, --dialog               Output message as Dialog Format.
                             \`partclone\` 相關選項。
  -I, --ignore_fschk         忽略檔案系統檢查。 \`partclone\` 相關選項。
      --ignore_crc           忽略 crc 檢查。 \`partclone\` 相關選項。
  -F, --force                強制執行。 \`partclone\` 相關選項。
  -f, --UI-fresh <sec>       Fresh times of progress.  \`partclone\` 相關選項。
  -z, --buffer_size <size>   讀取或寫入的緩衝區大小。 預設為 1048576。
                             \`partclone\` 相關選項。
  -q, --quiet                無聲模式。 停用進度訊息顯示。
                             \`partclone\` 相關選項。
  -d, --debug <level>        設定除錯層級 [1|2|3]。 \`partclone\` 相關選項。
"
help_partcloneOpt=`echo "$help_partcloneOpt" | sed '1d' | sed '$d'`
fnOpt_partcloneOpt() {
    local tmp="$1"
    [ ${#tmp} -eq 2 ] && tmp=${tmp:1:1}
    case "$tmp" in
        [DRCNXIFq] | --domain | --restore_raw_file | --rescue \
            | --no_check | --ncurse | --dialog | --ignore_fschk \
            | --ignore_crc | --force | --quiet )
            opt_partcloneOpt+=" $1"
            return 1
            ;;
        [lfz] | --logfile | --UI-fresh | --buffer_size )
            [ -z "$2" ] && return 4

            opt_partcloneOpt+=" $1 $2"
            return 2
            ;;
        d | --debug | --offset_domain )
            [ -z "$2" ] && return 4

            [ ${#opt} -eq 1 ] \
                && opt_partcloneOpt+=" $1$2" \
                || opt_partcloneOpt+=" $1=$2"
            return 2
            ;;
        * ) return 3 ;;
    esac
}


##shStyle 函式庫


rtnCutArray=()
fnCutArray() {
    local separator strTxt
    separator="$1"
    strTxt="$2"

    local idx val
    local arrAns=()

    idx=2
    while [ 1 ]
    do
        val=`echo "$separator$strTxt" | cut -d "$separator" -f $idx`
        [ "$val" == "" ] && break
        arrAns[ ${#arrAns[@]} ]=$val
        (( idx++ ))
    done

    rtnCutArray=("${arrAns[@]}")
}

fnRandomStr() {
    local loop rem
    local random=$RANDOM
    local strAns=""
    for loop in {1..2}
    do
        rem=$[ $random & 15 ]
        random=$[ $random >> 4 ]
        strAns+=${fnRandomStr_count16:$rem:1}
    done
    echo $strAns
}
fnRandomStr_count16="0123456789ABCDEF"

fnCheckMountState() {
    [ -z "$*" ] && return
    [ $fnCheckMountState_hasCheck -eq 1 ] && return

    local tmp val
    local bisHasNotCheck=0
    local bisHasUmount=0

    ## lsblk img
    # 錯誤 lsblk 不能處理非裝置
    # 但若執行 /dev/loop 又會因為未卸載而退出
    for val in "$@"
    do
        tmp=`lsblk -o MOUNTPOINT "$val" 2> /dev/null`
        if [ $? -ne 0 ]; then
            bisHasNotCheck=1
            printf "$_fYelB%s$_fN\n" \
                "無法確認 \"$val\" 是否已卸載！"
        elif [ -n "`echo "$tmp" | sed "1d" | grep .`" ]; then
            bisHasUmount=1
            Loxog err "請卸載 \"$val\" 裝置。"
        fi
    done

    [ $bisHasUmount -eq 1 ] && exit 1

    if [ $bisHasNotCheck -eq 1 ]; then
        printf "$_fYelB%s\n%s$_fN %s" \
            "！！！ 未卸載的裝置可能會有誤刪資料的風險 ！！！" \
            "請手動檢查無法確認之裝置。" \
            "（<Ctrl+c> 退出； <Enter> 繼續；）"
        read
        echo
    fi

    fnCheckMountState_hasCheck=1
}
fnCheckMountState_hasCheck=0
fnCheckMountState_hasNotCheck=0

rtnParseDeviceList_pt=()
rtnParseDeviceList_store=()
fnParseDeviceList() {
    if [ -z "$*" ]; then
        Loxog err "未指定裝置。"
        exit 1
    fi

    local val ptType
    local hasNoAllowDevice=0
    local devicePtList=()
    local deviceList=()

    for val in "$@"
    do
        ptType=`blkid -o value -s PTTYPE "$val"`
        if [ $? -ne 0 ]; then
            hasNoAllowDevice=1
            Loxog err "找不到 \"$val\" 裝置。"
            continue
        elif [ -n "$ptType" ] && [ "$ptType" != "gpt" ]; then
            hasNoAllowDevice=1
            Loxog err '尚未對非 "GPT" 分區表的裝置提供服務。'
            continue
        fi

        [ "$ptType" == "gpt" ] \
            && devicePtList[ ${#devicePtList[@]} ]=$val \
            || deviceList[ ${#deviceList[@]} ]=$val
    done

    [ $hasNoAllowDevice -ne 0 ] && exit 1
    fnCheckMountState "${devicePtList[@]}" "${deviceList[@]}"

    rtnParseDeviceList_pt=("${devicePtList[@]}")
    rtnParseDeviceList_store=("${deviceList[@]}")
}

# lsblk 資訊時而空白
fnBlkidTable() {
    local showList="$1"; shift

    fnCutArray "," "$showList"
    showList=("${rtnCutArray[@]}")

    local tmp idx val deviceName
    local blkidInfo=""
    local arrInfo=()
    local txtInfo=""
    local formatArgus=""
    local strAns=""

    for deviceName in "$@"
    do
        txtInfo+=$_br"0 $deviceName"
        arrInfo[ ${#arrInfo[@]} ]=$deviceName

        idx=1
        for val in "${showList[@]}"
        do
            blkidInfo=`blkid -s "$val" -o value "$deviceName"`
            arrInfo[ ${#arrInfo[@]} ]=$blkidInfo
            txtInfo+=$_br"$idx $blkidInfo"
            (( idx++ ))
        done
    done

    idx=1
    for idx in `seq 0 ${#showList[@]}`
    do
        tmp=${showList[ $(( $idx - 1 )) ]}$_br
        tmp+=`echo "$txtInfo" | grep "^$idx " | cut -d " " -f 2-`
        formatArgus+="   %-"`echo "$tmp" | wc -L`"s"
    done
    formatArgus=${formatArgus:3}$_br

    printf "$formatArgus" "DEVNAME" "${showList[@]}"
    printf "$formatArgus" "${arrInfo[@]}"
}

rtnGetInfo=""
fnGetInfo() {
    local val
    local devId lsblkInfo
    local gdiskInfo=""

    devId=`fnBlkidTable "PTTYPE,UUID,PARTUUID" \
        "${fnGetInfo_devicePtList[@]}" \
        "${fnGetInfo_deviceList[@]}"`

    if [ ${#fnGetInfo_devicePtList[@]} -ne 0 ]; then
        for val in "${fnGetInfo_devicePtList[@]}"
        do
            [ -n "$gdiskInfo" ] && gdiskInfo+=$_br$_br
            gdiskInfo+="# $val"
            gdiskInfo+=$_br`sgdisk -p "$val"`
        done
    else
        gdiskInfo="# 不包含分區表裝置"
    fi

    lsblkInfo=`fnBlkidTable \
        "PTTYPE,TYPE,LABEL,UUID,PARTLABEL,PARTUUID" \
        "${fnGetInfo_devicePtList[@]}" \
        "${fnGetInfo_deviceList[@]}"`

    fnGetInfo_mountDevice "${fnGetInfo_deviceList[@]}"
    fnGetInfo_MdForm "$devId" "$gdiskInfo" "$lsblkInfo" \
        "$fnGetInfo_du" "$fnGetInfo_fstab"
}
fnGetInfo_devicePtList=()
fnGetInfo_deviceList=()
fnGetInfo_du=""
fnGetInfo_fstab=""
fnGetInfo_mountDevice() {
    if [ -z "$*" ]; then
        fnGetInfo_du="# 不包含儲存裝置"
        fnGetInfo_fstab="# 不包含根目錄裝置"
        return
    fi

    fnCheckMountState "$@"

    local tmp val fstabPath
    local mountDevPath="/tmp/mountDev.tmp"
    local canNotmount=0
    local canNotumount=0
    local mountList=()
    local dfInfo=""
    local fstabInfo=""

    if [ -e "$mountDevPath" ]; then
        Loxog err "請搬移 \"$mountDevPath\" 目錄或文件供暫時的掛載使用。"
        exit 1
    fi
    mkdir "$mountDevPath"

    for val in "$@"
    do
        tmp="$mountDevPath/$val"
        mkdir -p "$tmp"
        mount "$val" "$tmp"
        [ $? -ne 0 ] && canNotmount=1 && Loxog err "無法掛載 \"$val\" 裝置。"
        [ $canNotumount -ne 0 ] && continue
        mountList[ ${#mountList[@]} ]=$tmp

        fstabPath="$tmp/etc/fstab"
        [ ! -f "$fstabPath" ] && continue
        [ -n "$fstabInfo" ] && fstabInfo+=$_br$_br
        fstabInfo+="## $val"
        fstabInfo+=$_br`cat "$fstabPath"`
    done
    [ $canNotmount -ne 0 ] \
        && Loxog err "請卸載 \"$mountDevPath\" 下的掛載裝置。" \
        && exit 1

    [ -z "$fstabInfo" ] && fstabInfo="# 不包含根目錄裝置"
    dfInfo=`df -h \
        --output=source,fstype,size,used,avail,pcent,target \
        "${mountList[@]}"`
    tmp=`echo "$PWD" | sed 's/\//\\\\\//g'`
    dfInfo=`echo "$dfInfo" | sed "s/$tmp//"`


    for val in "$@"
    do
        umount "$mountDevPath/$val"
        [ $? -ne 0 ] && canNotumount=1
    done

    if [ $canNotumount -eq 0 ]; then
        rm -rf "$mountDevPath"
    else
        Loxog err "無法卸載 \"$mountDevPath\" 下的掛載裝置。"
        exit 1
    fi

    fnGetInfo_du="$dfInfo"
    fnGetInfo_fstab="$fstabInfo"
}
fnGetInfo_MdForm() {
    local devId="$1"
    local gdiskInfo="$2"
    local lsblkInfo="$3"
    local dfInfo="$4"
    local fstabInfo="$5"

    local tmp
    local helPre="\`\`\`"
    local txtForm=""

    fnOneMsg() {
        local title="$1"
        local msg="$2"

        local txtAns=""
        txtAns+="**$title**："
        txtAns+=$_br
        txtAns+=$_br$helPre
        txtAns+=$_br$msg
        txtAns+=$_br$helPre
        txtAns+=$_br

        echo "$txtAns"
    }

    txtForm+="裝置資訊"
    txtForm+=$_br"======="
    txtForm+=$_br$_br
    txtForm+=$_br"> 主機識別碼："
    txtForm+=$_br"> $helPre"
    txtForm+=$_br"`echo "$devId" | sed "s/\(.*\)/> \1/"`"
    # txtForm+=$_br`echo "$devId" | sed "s/\(.*\)/> \1/"`
    txtForm+=$_br"> $helPre"
    txtForm+=$_br$_br$_br
    tmp=`uname -a`
    txtForm+=`fnOneMsg "uname -a" "$tmp"`
    txtForm+=$_br$_br
    txtForm+=`fnOneMsg "sgdisk -p" "$gdiskInfo"`
    txtForm+=$_br$_br
    txtForm+=`fnOneMsg "lsbik" "$lsblkInfo"`
    txtForm+=$_br$_br
    txtForm+=`fnOneMsg "df" "$dfInfo"`
    txtForm+=$_br$_br
    txtForm+=`fnOneMsg "cat /etc/fstab" "$fstabInfo"`
    txtForm+=$_br

    rtnGetInfo=$txtForm
}

rtnBackupCode_restore=""
rtnBackupCode_clone=""
fnBackupCode() {
    local val
    local deviceType="$1"
    local customOpt="$2"; shift 2

    local restoreSh=""
    local cloneSh=""

    for val in "$@"
    do
        [ -n "$restoreSh" ] && restoreSh+=$_br && cloneSh+=$_br
        fnBackupCode_single "$deviceType" "$customOpt" "$val"
        restoreSh+="$fnBackupCode_singleRestore"
        cloneSh+="$fnBackupCode_singleClone"
    done

    rtnBackupCode_restore="$restoreSh"
    rtnBackupCode_clone="$cloneSh"
}
fnBackupCode_singleRestore=""
fnBackupCode_singleClone=""
fnBackupCode_single() {
    local tmp tmpRestore tmpClone
    local deviceType="$1"
    local customOpt="$2"
    local device="$3"

    local name fsType
    local restoreCode=""
    local cloneCode=""

    tmpRestore='device="$1"; shift;'
    tmpClone='[ -n "$1" ] && device="$1" || device="'`realpath "$device"`'"; shift;'
    case "$deviceType" in
        GPT )
            name="./partitionData_`basename "$device"`.`fnRandomStr`.gpt"
            tmp=$_br'sgdisk '$customOpt
            tmpRestore+=$tmp
            tmpClone+=$tmp
            restoreCode=$tmpRestore' --load-backup "'$name'" "$device"'
            cloneCode=$tmpClone' --backup "'$name'" "$device"'
            ;;
        store )
            fsType=`blkid -o value -s TYPE "$device"`
            name=`basename "$device" | sed "s/\([^.]*\)\..*/\1/g"`
            name="device_${name}_${fsType}.`fnRandomStr`.ptcl.img"
            tmp=$_br"partclone.$fsType"
            tmpRestore+=$tmp
            tmpClone+=$tmp
            restoreCode=$tmpRestore' --restore '$customOpt' -s "'$name'" -o "$device"'
            cloneCode=$tmpClone' --clone '$customOpt' -s "$device" -o "'$name'"'
            ;;
    esac

    fnBackupCode_singleRestore=$restoreCode
    fnBackupCode_singleClone=$cloneCode
}


##shStyle 腳本環境


[ -L "$0" ] && exec "`realpath "$0"`" "$@"

__filename=`realpath "$0"`
_dirsh=`dirname "$__filename"`
[ "$_originPlace" == "bin" ] && _binsh=$_dirsh || _binsh=`realpath "$_dirsh/../../bin"`
[ "$_originPlace" == "bin" ] && _libsh=`realpath "$_dirsh/../lib"` || _libsh=`realpath "$_dirsh/.."`
_fileName=`basename "$0"`

_IFS=$IFS
_br="
"

tmp=`tput colors`
if [ -t 1 ] && [ -n "$tmp" ] && [ $tmp -ge 8 ]; then
    _fN=`tput sgr0`
    _f_bold=`tput bold`
    _fRed=`tput setaf 1`
    _fYel=`tput setaf 3`
    _fRedB=$_fRed$_f_bold
    _fYelB=$_fYel$_f_bold
fi

Loxog() {
    local _stdin=`[ ! -t 0 ] && { \
        IFS='';
        while read pipeData; do echo "$pipeData"; done <&0;
        IFS=$_IFS;
    }`
    local method="$1"; shift

    local color formatArgus

    case $method in
        war ) color=$_fYelB ;;
        err ) color=$_fRedB ;;
    esac

    formatArgus="$color%s$_fN\n"

    local idx val len

    [ -n "$*" ] && printf "$formatArgus" "$@" 1>&2

    [ -z "$_stdin" ] && return
    len=`echo "$_stdin" | wc -l`
    for idx in `seq 1 $len`
    do
        val=`echo "$_stdin" | sed -n "${idx}p"`
        printf "$formatArgus" "$val" 1>&2
    done
}


##shStyle ###


_stdin=`[ ! -t 0 ] && while read pipeData; do echo $pipeData; done <&0`

_args=("$@")
_origArgs=("$@")

argsShift() {
    local amount=$1

    if [ -z "$amount" ] || [ $amount -lt 1 ]; then amount=1; fi
    _args=("${_args[@]:$amount}")
}

_fnForceColor() {
    _fN="\e[00m"
    _f_bold="\e[01m"
    _fRed="\e[31m"
    _fYel="\e[33m"
    _fRedB=$_fRed$_f_bold
    _fYelB=$_fYel$_f_bold
}

fnParseOption() {
    local fnHandleOpt="fnOpt_$_shCmd"

    local tmp args opt val cutLen errMsg
    args=("${_args[@]}")
    errMsg=""

    while [ 1 ]
    do
        opt=${args[0]}
        val=${args[1]}
        cutLen=2

        if [ "$opt" == "--" ] || [ -z "`echo "_$opt" | grep "^_-"`" ]; then break; fi

        if [ -n "`echo "_$opt" | grep "^_-[^-]"`" ] && [ ${#opt} -ne 2 ]; then
            tmp="-"${opt:2}
            opt=${opt:0:2}
            val=""
            cutLen=1
            args=("$opt" "$tmp" "${args[@]:1}")
        elif [ -n "`echo "_$val" | grep "^_-"`" ]; then
            val=""
            cutLen=1
        fi

        if [ "$opt" == "--color" ]; then
            _fnForceColor
            tmp=1
        else
            $fnHandleOpt "$opt" "$val"
            tmp=$?
        fi
        case $tmp in
            0 )
                echo '請檢查 "'$fnHandleOpt'" 的錯誤回傳值。' 1>&2
                exit
                ;;
            # 使用 1 個參數
            1 )
                [ $cutLen -eq 2 ] && (( cutLen-- ))
                ;;
            # 使用 2 個參數
            2 ) ;;
            3 )
                errMsg+=$_br'找不到 "'$opt'" 選項。'
                ;;
            4 )
                [ "$val" == "" ] && val="null" || val='"'$val'"'
                errMsg+=$_br$val' 不符合 "'$opt'" 選項的預期值。'
                ;;
        esac

        args=("${args[@]:$cutLen}")
    done

    if [ "${args[0]}" == "--" ]; then
        args=("${args[@]:1}")
    else
        for val in "${args[@]}"
        do
            [ -z "`echo "_$val" | grep "^_-"`" ] && continue

            errMsg+=$_br'不符合 "[命令] [選項] [參數]" 的命令用法。'
            break
        done
    fi

    if [ -z "$errMsg" ]; then
        _args=("${args[@]}")
        return
    fi

    echo "$errMsg" | sed "1d" \
        | sed "s/^\(.\)/[$_fileName]: \1/" \
        | Loxog err
    exit 1
}

fnShowHelp() {
    local txtHelp=`fnHelp_$_shCmd`

    local bisUsage bisSubCmd bisOpt
    local usage
    bisUsage=` echo "$txtHelp" | grep "\[\[USAGE\]\]"`
    bisSubCmd=`echo "$txtHelp" | grep "\[\[SUBCMD\]\]"`
    bisOpt=`   echo "$txtHelp" | grep "\[\[OPT\]\]"`

    if [ -n "$bisUsage" ]; then
        usage="用法："
        [ -n "$bisSubCmd" ] && usage+=" [命令]"
        [ -n "$bisOpt" ] && usage+=" [選項]"

        txtHelp=`echo "$txtHelp" | sed "s/\[\[USAGE\]\]/\n$usage/"`
    fi

    [ -n "$bisSubCmd" ] && \
        txtHelp=`echo "$txtHelp" | sed "s/\[\[SUBCMD\]\]/\\n\\n命令：\\n/"`

    [ -n "$bisOpt" ] && \
        txtHelp=`echo "$txtHelp" | sed "s/\[\[OPT\]\]/\\n\\n選項：\\n/"`

    echo "$txtHelp$_br"
    exit
}


_shCmd=""
_shCmdLevel=0
_shScript "$@"
[ $_shCmdLevel -eq 0 ] && _shCmd="main" && fnMain "$@" && exit
for tmp in `seq 0 $(( $_shCmdLevel -1 ))`
do _shCmd+="_${_args[ $tmp ]}"; done
argsShift $_shCmdLevel
_shCmd=${_shCmd:1}
fnMain_$_shCmd "${_args[@]}"

